\chapter{System Design}
\label{ch:design}

\section{Overview}

This chapter presents the architectural and detailed design of SIREN, building upon the requirements established in Chapter 3. The design employs a modular three-tier architecture ensuring separation of concerns, scalability, and maintainability. Design decisions prioritize simplicity and accessibility for SME deployment while maintaining robust security incident management capabilities.

\section{Architecture Design}

\subsection{System Architecture}

Figure \ref{fig:system_arch} illustrates SIREN's overall system architecture.

\begin{figure}[H]
\centering
\begin{verbatim}
+------------------+         +------------------+         +------------------+
|  Web Browser     |         |                  |         |  Windows Agent   |
|  (Client)        |<------->|  SIREN Platform  |<------->|  (Endpoints)     |
|                  |  HTTPS  |                  |  HTTPS  |                  |
|  - React UI      |         |  Backend Server  |         |  - Event Monitor |
|  - Dashboard     |         |  - FastAPI       |         |  - Local Filter  |
|  - Investigation |         |  - Correlation   |         |  - Event Forward |
+------------------+         |  - Alerting      |         +------------------+
                             |                  |
                             |  +------------+  |
                             |  | PostgreSQL |  |
                             |  | Database   |  |
                             |  +------------+  |
                             +------------------+

Data Flow:
1. Agents collect Windows events → Forward to Backend
2. Backend normalizes → Stores in Database → Runs correlation
3. Correlation Engine detects patterns → Generates incidents
4. Alert Service notifies analysts via email/webhook
5. Frontend queries API → Displays incidents and events
\end{verbatim}
\caption{SIREN System Architecture}
\label{fig:system_arch}
\end{figure}

\subsection{Component Responsibilities}

\textbf{Frontend (React TypeScript):}
\begin{itemize}
    \item Renders dashboard displaying real-time security metrics
    \item Provides incident investigation interface
    \item Manages user interactions and form submissions
    \item Executes API calls to backend services
\end{itemize}

\textbf{Backend (FastAPI):}
\begin{itemize}
    \item Exposes REST API endpoints for all operations
    \item Implements correlation engine for event analysis
    \item Manages incident lifecycle and workflow
    \item Handles authentication and authorization
    \item Orchestrates alert notifications
\end{itemize}

\textbf{Database (PostgreSQL):}
\begin{itemize}
    \item Stores security events with timestamps and metadata
    \item Maintains incident records with status tracking
    \item Holds correlation rules and configurations
    \item Supports efficient time-series queries
\end{itemize}

\textbf{Windows Agent (Python):}
\begin{itemize}
    \item Monitors Windows Event Logs and Sysmon
    \item Filters events based on security relevance
    \item Forwards events to backend via authenticated API
    \item Operates with minimal resource footprint
\end{itemize}

\section{Database Design}

\subsection{Schema Design}

The database schema supports efficient event storage and rapid incident queries.

\begin{figure}[H]
\centering
\begin{verbatim}
+-------------------+       +-------------------+       +-------------------+
| events            |       | incidents         |       | correlation_rules |
+-------------------+       +-------------------+       +-------------------+
| id (PK)          |       | id (PK)          |       | id (PK)          |
| timestamp        |       | created_at       |       | name             |
| source           |       | severity         |       | description      |
| event_type       |       | status           |       | pattern          |
| severity         |       | title            |       | threshold        |
| hostname         |       | description      |       | timewindow       |
| event_data (JSON)|       | assigned_to      |       | enabled          |
| incident_id (FK) |       +-------------------+       +-------------------+
+-------------------+              |
        |                          |
        +------+-------------------+
               |
        +------v--------+
        | event_incident|
        | (many-to-many)|
        +---------------+
        | event_id (FK) |
        | incident_id(FK)|
        +---------------+

Indexes:
- events.timestamp (B-tree) for time-range queries
- events.hostname (Hash) for host-specific searches
- incidents.status (Hash) for status filtering
- incidents.created_at (B-tree) for timeline queries
\end{verbatim}
\caption{Database Schema showing entity relationships}
\label{fig:db_schema}
\end{figure}

\subsection{Data Models}

\textbf{Event Model:}
Events represent individual security occurrences captured from endpoints. The JSON event\_data field provides flexibility for varying event structures while maintaining queryable common fields.

\textbf{Incident Model:}
Incidents aggregate related events based on correlation rules. Status field supports workflow states (new, investigating, contained, resolved). Severity classification (low, medium, high, critical) drives alert prioritization.

\textbf{Correlation Rule Model:}
Rules define patterns triggering incident generation. Pattern field specifies matching criteria (e.g., "5 failed logins from same IP"). Timewindow constrains temporal correlation scope.

\section{Interface Design}

\subsection{Dashboard Design}

The dashboard provides at-a-glance security status visibility:

\textbf{Layout Structure:}
\begin{itemize}
    \item Header: Logo, navigation menu, user profile
    \item Summary Cards: Total incidents, active alerts, monitored hosts, event rate
    \item Visualization Panel: Incident severity pie chart, event timeline graph
    \item Recent Incidents Table: Latest 10 incidents with severity, timestamp, status
    \item Quick Actions: Create manual incident, view all events, configure rules
\end{itemize}

\subsection{Incident Investigation Interface}

Investigation workflow centers on comprehensive event context:

\textbf{Components:}
\begin{itemize}
    \item Incident Header: Title, severity badge, status, timestamps
    \item Event Timeline: Chronological display of correlated events
    \item Affected Assets: List of involved hostnames and IP addresses
    \item Investigation Notes: Analyst comments and observations
    \item Action Buttons: Update status, assign analyst, export report
\end{itemize}

\subsection{Configuration Interface}

Administrative functions support system customization:

\textbf{Correlation Rules Management:}
Form-based rule creation specifying event patterns, thresholds, time windows, and severity mappings.

\textbf{Alert Configuration:}
Email SMTP settings, webhook URLs, notification templates, escalation policies.

\textbf{User Management:}
User account creation, role assignment (admin, analyst, viewer), permission management.

\section{API Design}

The REST API follows standard conventions for consistency and discoverability.

\subsection{Endpoint Structure}

\begin{verbatim}
Event Operations:
  POST   /api/events              - Ingest new event
  GET    /api/events              - List events (with filters)
  GET    /api/events/{id}         - Get event details

Incident Operations:
  GET    /api/incidents           - List incidents
  GET    /api/incidents/{id}      - Get incident details
  POST   /api/incidents           - Create manual incident
  PUT    /api/incidents/{id}      - Update incident
  
Dashboard Operations:
  GET    /api/dashboard/stats     - Get summary statistics
  GET    /api/dashboard/timeline  - Get event timeline data

Configuration Operations:
  GET    /api/rules               - List correlation rules
  POST   /api/rules               - Create rule
  PUT    /api/rules/{id}          - Update rule
  DELETE /api/rules/{id}          - Delete rule
\end{verbatim}

\subsection{Authentication Design}

JWT (JSON Web Token) based authentication provides stateless security:

\begin{enumerate}
    \item User submits credentials to /api/auth/login
    \item Backend validates credentials, generates JWT containing user ID and role
    \item Client stores JWT, includes in Authorization header for subsequent requests
    \item Backend validates JWT signature on each request, extracts user context
    \item Tokens expire after configurable duration, requiring re-authentication
\end{enumerate}

\section{Security Design}

\subsection{Data Protection}

\textbf{Encryption in Transit:}
All communications use HTTPS with TLS 1.2+ encryption.

\textbf{Encryption at Rest:}
Sensitive configuration data (SMTP passwords, API keys) encrypted using AES-256.

\textbf{Input Validation:}
All API inputs validated using Pydantic schemas, preventing injection attacks.

\textbf{SQL Injection Prevention:}
SQLAlchemy ORM with parameterized queries eliminates SQL injection vectors.

\subsection{Access Control}

Role-Based Access Control (RBAC) enforces authorization:

\begin{itemize}
    \item \textbf{Administrator:} Full system access, configuration management, user management
    \item \textbf{Analyst:} Incident investigation, event viewing, status updates
    \item \textbf{Viewer:} Read-only dashboard and incident access
\end{itemize}

\section{Scalability Design}

\subsection{Horizontal Scaling}

Backend services designed as stateless components enabling horizontal scaling:
\begin{itemize}
    \item Multiple FastAPI instances behind load balancer
    \item Session state stored in database, not server memory
    \item Correlation engine can run as separate scalable service
\end{itemize}

\subsection{Database Optimization}

\begin{itemize}
    \item Indexes on frequently queried fields
    \item Partitioning events table by timestamp for large deployments
    \item Archival strategy moving old events to separate storage
    \item Connection pooling limiting concurrent database connections
\end{itemize}

\section{Summary}

This chapter detailed SIREN's system design across architecture, database, interface, API, and security dimensions. The modular three-tier design separates concerns while enabling component-level scaling. Database schema optimizes time-series event queries while supporting flexible correlation. Interface design prioritizes analyst workflow efficiency. Security design implements defense-in-depth protecting data and access. The architecture balances simplicity for SME deployment with robustness for production security operations.
